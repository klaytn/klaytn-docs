# caver.contract <a id="caver-contract"></a>

The `caver.contract` object makes it easy to interact with smart contracts on the Klaytn blockchain platform. When you create a new contract object, you have to provide the JSON interface for that smart contract and caver-js will automatically convert all calls with contract object in javascript into low level ABI calls over RPC for you.

This allows you to interact with smart contracts as if they were JavaScript objects.

## caver.contract <a id="new-contract"></a>

```javascript
new caver.contract(jsonInterface [, address] [, options])
```
Creates a new contract instance with all its methods and events defined in its JSON interface object.

**Parameters**

| Name | Type | Description |
| --- | --- | --- |
| jsonInterface | object | The JSON interface for the contract to instantiate |
| address | string | (optional) The address of the smart contract to call. Can be added later using ``myContract.options.address = '0x1234..'`` |
| options | object | (optional) The options of the contract.  See the table below for the details. |

The options object contains the following:

| Name | Type | Description |
| --- | --- | --- |
| from | string | (optional) The address from which transactions should be made. |
| gasPrice | string | (optional) The gas price in peb to use for transactions. |
| gas | number | (optional) The maximum gas provided for a transaction (gas limit). |
| data | string | (optional) The byte code of the contract. Used when the contract gets deployed. |

**Return Value**

`Promise` returns `object`

| Type | Description |
| --- | --- |
| object | The contract instance with all its methods and events. |


**Example**

```javascript
const myContract = new caver.contract([...], '0x{address in hex}', { gasPrice: '25000000000' })
```

## myContract.options <a id="mycontract-options"></a>

```javascript
myContract.options
```

The `options` object for the contract instance. `from`, `gas` and `gasPrice` are used as fallback values when sending transactions.

**Properties**

| Name | Type | Description |
| --- | --- | --- |
| address | string | The address where the contract is deployed. |
| jsonInterface | Array | The JSON interface of the contract. |
| from | string | The default from address which transactions should be made. When the transaction is created, if the from address is not defined in the option, this `myContract.options.from` is always used to create the transaction. |
| gasPrice | string | The gas price in peb to use for transactions. |
| gas | number | The maximum gas provided for a transaction (gas limit). |
| data | string | The byte code of the contract. Used when the contract gets deployed. |


**Example**

```javascript
> myContract.options
{
  address: [Getter/Setter],
  jsonInterface: [Getter/Setter],
  from: [Getter/Setter],
  gasPrice: [Getter/Setter],
  gas: [Getter/Setter],
  data: [Getter/Setter]
}

> myContract.options.from = '0x1234567890123456789012345678901234567891' // default from address
> myContract.options.gasPrice = '25000000000000' // default gas price in peb
> myContract.options.gas = 5000000 // provide as fallback always 5M gas
```


## myContract.options.address <a id="mycontract-options-address"></a>

```javascript
myContract.options.address
```

The address used for this contract instance `myContract`. All transactions generated by caver-js from this contract will contain this address as the `to` of the transaction.

**Property**

| Name | Type | Description |
| --- | --- | --- |
| address | string &#124; `null` | The address for this contract or `null` if it is not yet set. |

**Example**

```javascript
>  myContract.options.address
'0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae'

// set a contract address
>  myContract.options.address = '0x1234FFDD...'
```

## myContract.options.jsonInterface <a id="mycontract-options-jsoninterface"></a>

```javascript
myContract.options.jsonInterface
```
The JSON interface object derived from the ABI of this contract `myContract`.

**Property**

| Name | Type | Description |
| --- | --- | --- |
| jsonInterface | Array | The JSON interface for this contract. Re-setting this will regenerate the methods and events of the contract instance. |


**Example**

```javascript
> myContract.options.jsonInterface
[
	{
		constant: true,
		inputs: [ { name: 'interfaceId', type: 'bytes4' } ],
		name: 'supportsInterface',
		outputs: [ { name: '', type: 'bool' } ],
		payable: false,
		stateMutability: 'view',
		type: 'function',
		signature: '0x01ffc9a7',
	},
	...
	{
		anonymous: false,
		inputs: [
			{ indexed: true, name: 'owner', type: 'address' },
			{ indexed: true, name: 'spender', type: 'address' },
			{ indexed: false, name: 'value', type: 'uint256' }
		],
		name: 'Approval',
		type: 'event',
		signature: '0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925',
	},
]

// set a new jsonInterface
> myContract.options.jsonInterface = [...]
```


## myContract.clone <a id="mycontract-clone"></a>

```javascript
myContract.clone([contractAddress])
```

Clones the current contract instance.

**Parameters**

| Name | Type | Description |
| --- | --- | --- |
| contractAddress | String | (optional) The address of the new contract. If omitted, it will be set to the address in the original instance (e.g., `myContract.options.address`). |

**Return Value**

| Type | Description |
| --- | --- |
| object | The new cloned contract instance. |


**Example**

```javascript
> myContract.clone()
Contract {
  currentProvider: [Getter/Setter],
  ...
  _keyrings: KeyringContainer { ... }
}
```


## myContract.deploy <a id="mycontract-deploy"></a>

```javascript
myContract.deploy(options)
```

Deploys the contract to the Klaytn. After successful deployment, the promise will be resolved with a new contract instance.

**NOTE** The keyring with the from address that sends the transaction must exist in the caver.wallet.

**Parameters**

| Name | Type | Description |
| --- | --- | --- |
| options | object | The options object used for deployment. See the below table to find the description. |

The options object can contain the following:

| Name | Type | Description |
| --- | --- | --- |
| data | string | The byte code of the contract. |
| arguments | Array | (optional) The arguments that get passed to the constructor on deployment. |

**Return Value**

`Promise` returning `object` - An object in which arguments and functions for contract distribution are defined.:

| Name | Type | Description |
| --- | --- | --- |
| arguments | Array | The arguments passed in `options.arguments`. |
| [send](#myContract-methods-methodname-send) | function | The function will deploy the contract to the Klaytn. The promise will be resolved with the new contract instance. |
| [estimateGas](#myContract-methods-methodname-estimategas) | function | The function will estimate the gas used for the deployment. |
| [encodeABI](#myContract-methods-methodname-encodeabi) | function | The function encodes the ABI of the deployment, which is contract data + constructor parameters. |

**Example**

```javascript
> myContract.deploy({
      data: '0x12345...',
      arguments: [123, 'My string']
  })
  .send({
      from: '0x1234567890123456789012345678901234567891',
      gas: 1500000,
      value: 0,
  }, function(error, transactionHash) { ... })
  .on('error', function(error) { ... })
  .on('transactionHash', function(transactionHash) { ... })
  .on('receipt', function(receipt) {
     console.log(receipt.contractAddress) // contains the new contract address
   })
  .then(function(newContractInstance) {
      console.log(newContractInstance.options.address) // instance with the new contract address
  })

// When the data is already set as an option to the contract itself
> myContract.options.data = '0x12345...'

> myContract.deploy({
        arguments: [123, 'My string']
  })
  .send({
      from: '0x1234567890123456789012345678901234567891',
      gas: 1500000,
      value: 0,
  })
  .then(function(newContractInstance) {
      console.log(newContractInstance.options.address) // instance with the new contract address
  })

// Simply encoding
> myContract.deploy({
      data: '0x12345...',
      arguments: [123, 'My string']
  })
  .encodeABI()
'0x12345...0000012345678765432'

// Gas estimation
> myContract.deploy({
      data: '0x12345...',
      arguments: [123, 'My string']
  })
  .estimateGas(function(err, gas) {
      console.log(gas)
  })
```


## myContract.methods <a id="mycontract-methods"></a>

```javascript
myContract.methods.methodName([param1 [, param2 [, ...]]])
```
Creates a transaction object for that method, which then can be called, sent, estimated or ABI encoded.

The methods of this smart contract are available through:

- The name: `myContract.methods.methodName(123)`
- The name with parameters: `myContract.methods['methodName(uint256)'](123)`
- The signature*: `myContract.methods['0x58cf5f10'](123)`

This allows calling functions with the same name but different parameters from the JavaScript contract object.

## cf) \*function signature (function selector)   <a id="cf-function-signature-function-selector"></a>
The first four bytes of the call data for a function call specifies the function to be called.  
It is the first (left, high-order in big-endian) four bytes of the Keccak-256 (SHA-3) hash of the signature of the function.

The function signature can be made by 2 different methods.  
`1. caver.abi.encodefunctionSignature('funcName(paramType1,paramType2,...)')`  
`2. caver.utils.sha3('funcName(paramType1,paramType2,...)').substr(0, 10)`

ex)  
```javascript
caver.abi.encodefunctionSignature('methodName(uint256)')
> 0x58cf5f10

caver.utils.sha3('methodName(uint256)').substr(0, 10)
> 0x58cf5f10
```

**Parameters**

Parameters of any method depend on the smart contracts methods, defined in the JSON interface.

**Return Value**

`Promise` returning `object` - An object in which arguments and functions for contract execution are defined.:

| Name | Type | Description |
| --- | --- | --- |
| arguments | Array | The arguments passed as arguments for method. |
| [call](#myContract-methods-methodname-call) | function | The function will call constant method and execute its smart contract method in the Klaytn Virtual Machine without sending a transaction (cannot alter the smart contract state). |
| [send](#myContract-methods-methodname-send) | function | The function will send a transaction to the Klaytn and execute its method (can alter the smart contract state). |
| [estimateGas](#myContract-methods-methodname-estimategas) | function | The function will estimate the gas used for the execution. |
| [encodeABI](#myContract-methods-methodname-encodeabi) | function | The function encodes the ABI for this method. This can be sent using a transaction, calling the method or passing into another smart contract method as argument. |

**Example**

```javascript
// calling a method
> myContract.methods.methodName(123).call({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'}, function(error, result) {
      ...
  })

// or sending and using a promise
> myContract.methods.methodName(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})
  .then(function(receipt) {
    // receipt can also be a new contract instance, when coming from a "contract.deploy({...}).send()"
  })

// or sending and using the events
> myContract.methods.methodName(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})
  .on('transactionHash', function(hash) {
      ...
  })
  .on('receipt', function(receipt) {
      ...
  })
  .on('error', console.error)
```


## methods.methodName.call <a id="methods-methodname-call"></a>

```javascript
myContract.methods.methodName([param1 [, param2 [, ...]]]).call(options [, callback])
```

Will call a "constant" method and execute its smart contract method in the Klaytn Virtual Machine without sending any transaction.  Note that calling cannot alter the smart contract state.

**Parameters**

| Name | Type | Description |
| --- | --- | --- |
| options | object | (optional) The options used for calling.  See the table below for the details. |
| callback | function | (optional) This callback will be fired with the result of the smart contract method execution as the second argument, or with an error object as the first argument. |

The options object can contain the following:

| Name | Type | Description |
| --- | --- | --- |
| from | string | (optional) The address the call “transaction” should be made from. |
| gasPrice | string | (optional) The gas price in peb to use for this call "transaction". |
| gas | number | (optional) The maximum gas provided for this call "transaction" (gas limit). |

**Return Value**

`Promise` returning `Mixed` - The return value(s) of the smart contract method. If it returns a single value, it is returned as it is. If it has multiple return values, they are returned as an object with properties and indices.

**Example**

```javascript
// using the promise
> myContract.methods.methodName(123).call({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})
  .then(function(result) {
      ...
  })
```

```solidity
// Solidity: MULTI-ARGUMENT RETURN
contract MyContract {
    function myfunction() returns(uint256 mynumber, string mystring) {
        return (23456, "Hello!%")
    }
}
```

```javascript
> var MyContract = new caver.contract(abi, address)
> MyContract.methods.myfunction().call().then(console.log)
Result {
      mynumber: '23456',
      mystring: 'Hello!%',
      0: '23456', // these are here as fallbacks if the name is not known or given
      1: 'Hello!%'
}
```

```solidity
// Solidity: SINGLE-ARGUMENT RETURN
contract MyContract {
    function myfunction() returns(string mystring) {
        return "Hello!%"
    }
}
```

```javascript
> var MyContract = new caver.contract(abi, address)
> MyContract.methods.myfunction().call().then(console.log)
"Hello!%"
```


## methods.methodName.send <a id="methods-methodname-send"></a>

```javascript
myContract.methods.methodName([param1 [, param2 [, ...]]]).send(options [, callback])
```

Will send a transaction to the smart contract and execute its method. This can alter the smart contract state.

**Parameters**

| Name | Type | Description |
| --- | --- | --- |
| options | object | The options used for sending.  See the table below for the details. |
| callback | function | (optional) This callback will be fired first with the "transactionHash", or with an error object as the first argument. |

The options object can contain the following:

| Name | Type | Description |
| --- | --- | --- |
| from | string | The address from which the transaction should be sent. If omitted, `myContract.options.from` will be used. |
| gasPrice | string | (optional) The gas price in peb to use for this transaction. |
| gas | number | (optional) The maximum gas provided for this transaction (gas limit). |
| value | number &#124; string &#124; BN &#124; Bignumber | (optional) The value transferred for the transaction in peb. |


**NOTE** The keyring corresponding to the `from` address that sends the transaction must exist in `caver.wallet`.

**Return Value**

| Type | Description |
| --- | --- |
| PromiEvent | A promise combined event emitter. Will be resolved when the transaction receipt is available, or if this `send()` is called from a `myContract.deploy()`, then the promise will be resolved with the new contract instance. Additionally, the following events are available |

For PromiEvent, the following events are available:

- `transactionHash` returns `string`: Is fired right after the transaction is sent and a transaction hash is available.
- `receipt` returns `object`: Is fired when the transaction receipt is available. See [caver.rpc.klay.getTransactionReceipt](./caver.rpc/caver.rpc.klay.md#caver-rpc-klay-gettransactionreceipt) for more detail.
- `error` returns ``Error``: Is fired if an error occurs during sending. On an out-of-gas error, the second parameter is the receipt.

**Example**

```javascript
// using the promise
> myContract.methods.methodName(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})
  .then(function(receipt) {
    // receipt can also be a new contract instance, when coming from a "contract.deploy({...}).send()"
  })


// using the event emitter
> myContract.methods.methodName(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})
  .on('transactionHash', function(hash) {
    ...
  })
  .on('receipt', function(receipt) {
    console.log(receipt)
  })
  .on('error', console.error) // If there is an out-of-gas error, the second parameter is the receipt.

// receipt example
{
   "transactionHash": "0x9fc76417374aa880d4449a1f7f31ec597f00b1f6f3dd2d66f4c9c6c445836d8b",
   "transactionIndex": 0,
   "blockHash": "0xef95f2f1ed3ca60b048b4bf67cde2195961e0bba6f70bcbea9a2c4e133e34b46",
   "blocknumber": 3,
   "contractAddress": "0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe",
   "gasUsed": 30234,
   "events": {
     "eventName": {
       returnValues: {
         myIndexedParam: 20,
         myOtherIndexedParam: '0x123456789...',
         myNonIndexParam: 'My string'
       },
       raw: {
         data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',
         topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']
       },
       event: 'eventName',
       signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',
       logIndex: 0,
       transactionIndex: 0,
       transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',
       blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',
       blocknumber: 1234,
       address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'
    },
    "MyOtherEvent": {
      ...
    },
    "MyMultipleEvent":[{...}, {...}] // If there are a multiple of the same events, they will be in an array.
  }
}
```


## methods.methodName.estimateGas <a id="methods-methodname-estimategas"></a>

```javascript
myContract.methods.methodName([param1 [, param2 [, ...]]]).estimateGas(options [, callback])
```

Will estimate the gas that a method execution will take when executed in the Klaytn Virtual Machine. The estimation can differ from the actual gas used when later sending a transaction, as the state of the smart contract can be different at that time.

**Parameters**

| Name | Type | Description |
| --- | --- | --- |
| options | object | (optional) The options used for calling.  See the table below for the details. |
| callback | function | (optional) This callback will be fired with the result of the gas estimation as the second argument, or with an error object as the first argument. |

The options object can contain the following:

| Name | Type | Description |
| --- | --- | --- |
| from | string | (optional) The address from which the call "transaction" should be made. |
| gas | number | (optional) The maximum gas provided for this call "transaction" (gas limit). Setting a specific value helps to detect out of gas errors. If all gas is used, it will return the same number. |
| value | number &#124; string &#124; BN &#124; Bignumber | (optional) The value transferred for the call "transaction" in peb. |

**Return Value**

`Promise` returns `number`

| Type | Description |
| --- | --- |
| number | The used gas for the simulated call/transaction. |

**Example**

```javascript
> myContract.methods.methodName(123).estimateGas({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})
  .then(function(gasAmount) {
    ...
  })
  .catch(function(error) {
    ...
  })
```


## methods.methodName.encodeABI <a id="methods-methodname-encodeabi"></a>

```javascript
myContract.methods.methodName([param1 [, param2[, ...]]]).encodeABI()
```

Encodes the ABI for this method. This can be used to send a transaction, call a method, or pass it into another smart contract method as arguments.


**Parameters**

Parameters of any method depend on the smart contracts methods, defined in the JSON interface.

**Return Value**

| Type | Description |
| --- | --- |
| string | The encoded ABI byte code to send via a transaction or call. |


**Example**

```javascript
> myContract.methods.methodName(123).encodeABI()
'0x58cf5f1000000000000000000000000000000000000000000000000000000000000007B'
```


## myContract.once <a id="mycontract-once"></a>

```javascript
myContract.once(event [, options], callback)
```

Subscribes to an event and unsubscribes immediately after the first event or error. Will only fire for a single event.

**Parameters**

| Name | Type | Description |
| --- | --- | --- |
| event | string | The name of the event in the contract, or `allEvents` to get all events. |
| options | object | (optional) The options used for subscription. See the table below for the details. |
| callback | function | This callback will be fired for the first event as the second argument, or an error as the first argument. See [myContract.getPastEvents](#mycontract-getpastevents) for details about the event structure. |

The options object can contain the following:

| Name | Type | Description |
| --- | --- | --- |
| filter | object | (optional) Lets you filter events by indexed parameters, *e.g.*, `{filter: {mynumber: [12,13]}}` means all events where "mynumber" is 12 or 13. |
| topics | Array | (optional) This allows you to manually set the topics for the event filter. If given the filter property and event signature, `topic[0]` will not be set automatically. |

**Return Value**

`Promise` returns `object` - An event object. For more detail about event object, please refer to [myContract.getPastEvents](#mycontract-getpastevents).

**Example**

```javascript
> myContract.once('eventName', {
    filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23
  }, function(error, event) { console.log(event) })

// event output example
{
    returnValues: {
        myIndexedParam: 20,
        myOtherIndexedParam: '0x123456789...',
        myNonIndexParam: 'My string'
    },
    raw: {
        data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',
        topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']
    },
    event: 'eventName',
    signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',
    logIndex: 0,
    transactionIndex: 0,
    transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',
    blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',
    blocknumber: 1234,
    address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'
}
```


## myContract.events <a id="mycontract-events"></a>

```javascript
myContract.events.eventName([options][, callback])
```

Subscribes to an event.

**Parameters**

| Name | Type | Description |
| --- | --- | --- |
| options | object | (optional) The options used for subscription. See the table below for the details. |
| callback | function | (optional) This callback will be fired for each event as the second argument, or an error as the first argument. |

The options object can contain the following:

| Name | Type | Description |
| --- | --- | --- |
| filter | object | (optional) Lets you filter events by indexed parameters, *e.g.*, `{filter: {mynumber: [12,13]}}` means all events where "mynumber" is 12 or 13. |
| fromBlock | number | (optional) The block number from which to get events on. |
| topics | Array | (optional) This allows to manually set the topics for the event filter. If given the filter property and event signature, `topic[0]` will not be set automatically. |


**Return Value**

`EventEmitter`: The event emitter has the following events:

| Name | Type | Description |
| --- | --- | --- |
| data | object | Fires on each incoming event with the event object as argument. |
| error | object | Fires when an error in the subscription occurs. |

The structure of the returned event `object` looks as follows:

| Name | Type | Description |
| --- | --- | --- |
| event | string | The event name. |
| signature | string &#124; `null` | The event signature, `null` if it is an anonymous event. |
| address | string | Address which from this event originated. |
| returnValues | object | The return values coming from the event, *e.g.*, `{myVar: 1, myVar2: '0x234...'}`. |
| logIndex | number | Integer of the event index position in the block. |
| transactionIndex | number | Integer of the transaction's index position where the event was created. |
| transactionHash | 32-byte string | Hash of the block this event was created in. `null` when it is still pending. |
| blockHash | 32-byte string | Hash of the block this event was created in. `null` when it is still pending. |
| blocknumber | number | The block number this log was created in. `null` when still pending. |
| raw.data | string | The data containing non-indexed log parameter. |
| raw.topics | Array | An array with max 4 32-byte topics, topic 1-3 contains indexed parameters of the event. |
| id | string | A log identifier. It is made through concatenating "log_" string with `keccak256(blockHash + transactionHash + logIndex).substr(0, 8)` |

**Example**

```javascript
> myContract.events.eventName({
    filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23
    fromBlock: 0
  }, function(error, event) { console.log(event) })
  .on('data', function(event){
      console.log(event) // same results as the optional callback above
  })
  .on('error', console.error)

// event output example
{
    returnValues: {
        myIndexedParam: 20,
        myOtherIndexedParam: '0x123456789...',
        myNonIndexParam: 'My string'
    },
    raw: {
        data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',
        topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']
    },
    event: 'eventName',
    signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',
    logIndex: 0,
    transactionIndex: 0,
    transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',
    blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',
    blocknumber: 1234,
    address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe',
    id: 'log_41d221bc',
}
```


## events.allEvents <a id="events-allevents"></a>

```javascript
myContract.events.allEvents([options] [, callback])
```
Same as [myContract.events](#mycontract-events) but receives all events from this smart contract.
Optionally, the filter property can filter those events.


## getPastEvents <a id="getpastevents"></a>

```javascript
myContract.getPastEvents(event [, options] [, callback])
```
Gets past events for this contract.

**Parameters**

| Name | Type | Description |
| --- | --- | --- |
| event | string | The name of the event in the contract, or `"allEvents"` to get all events. |
| options | object | (optional) The options used for subscription. See the table below for the details. |
| callback | function | (optional) This callback will be fired with an array of event logs as the second argument, or an error as the first argument. |

To options object can contain the following:

| Name | Type | Description |
| --- | --- | --- |
| filter | object | (optional) Lets you filter events by indexed parameters, *e.g.*, `{filter: {mynumber: [12,13]}}` means all events where "mynumber" is 12 or 13. |
| fromBlock | number | (optional) The block number from which to get events on. |
| toBlock | number | (optional) The block number to get events up to (defaults to `"latest"`). |
| topics | Array | (optional) This allows manually setting the topics for the event filter. If given the filter property and event signature, `topic[0]` will not be set automatically. |

**Return Value**

`Promise` returns `Array` - An array with the past event objects, matching the given event name and filter.

An event object can contain the following:

| Name | Type | Description |
| --- | --- | --- |
| event | string | The event name. |
| signature | string &#124; `null`| The event signature, null if it’s an anonymous event. |
| address | string | Address this event originated from. |
| returnValues | object | The return values coming from the event, e.g. {myVar: 1, myVar2: '0x234...'}. |
| logIndex | number | The event index position in the block. |
| transactionIndex | number | The transaction’s index position the event was created in. |
| transactionHash | string | The hash of the transaction this event was created in. |
| blockHash | string | The hash of the block this event was created in. null when it’s still pending. |
| blockNumber | number | The block number this log was created in. null when still pending. |
| raw | object | An object defines `data` and `topic`. `raw.data` containing non-indexed log parameter. `raw.topic` is an array with max 4 32 Byte topics, topic 1-3 contains indexed parameters of the event. |

**Example**

```javascript
> myContract.getPastEvents('eventName', {
      filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, // Using an array means OR: e.g. 20 or 23
      fromBlock: 0,
      toBlock: 'latest'
  }, function(error, events) { console.log(events) })
  .then(function(events) {
      console.log(events) // same results as the optional callback above
  })

[{
    returnValues: {
        myIndexedParam: 20,
        myOtherIndexedParam: '0x123456789...',
        myNonIndexParam: 'My string'
    },
    raw: {
        data: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',
        topics: ['0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7', '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385']
    },
    event: 'eventName',
    signature: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',
    logIndex: 0,
    transactionIndex: 0,
    transactionHash: '0x7f9fade1c0d57a7af66ab4ead79fade1c0d57a7af66ab4ead7c2c2eb7b11a91385',
    blockHash: '0xfd43ade1c09fade1c0d57a7af66ab4ead7c2c2eb7b11a91ffdd57a7af66ab4ead7',
    blocknumber: 1234,
    address: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'
},{
      ...
}]
```
