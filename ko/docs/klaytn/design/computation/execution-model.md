# 실행 모델(Execution Model)<a id="execution-model"></a>

이 장에서는 Klaytn 스마트 컨트랙트의 실행 모델, 데이터 구조 및 생명 주기에 관해 설명합니다.

## 실행 모델(Execution Model)<a id="execution-model"></a>

Transactions can be generated by platform APIs as described in [Platform API Specification](../../../dapp/json-rpc/api-references/README.md). 이 트랜잭션들은 블록에 저장되기 위해 _컨센서스 노드 \(CNs\)_로 보내집니다. CN은 전송된 각 트랜잭션이 유효한지 검사합니다. 유효한 트랜잭션은 트랜잭션 풀에 저장되고, 그렇지 않다면 버려집니다. CN은 트랜잭션 풀에서 현재 블록에서 실행 가능한 트랜잭션을 선택하고, 하나씩 실행합니다.

트랜잭션을 실행하려면 발신자가 일정량의 KLAY를 트랜잭션 수수료로 지불해야합니다. 트랜잭션 수수료는 사용된 가스와 단가(unit price)를 기준으로 계산됩니다. 가스는 연산의 기본적인 단위입니다. Klaytn 노드에서 실행되는 모든 연산은 미리 정의된 양의 가스를 소모합니다. 트랜잭션에 필요한 정확한 KLAY 양은 [트랜잭션 수수료](../transaction-fees/transaction-fees.md)에 설명된 공식으로 계산됩니다. 트랜잭션이 충분한 가스와 함께 보내지지 않는다면 트랜잭션은 실행되지 않습니다. 또한, 발신인의 잔고가 부족할 때도 트랜잭션이 보내지지 않습니다.

트랜잭션이 성공적으로 실행되면, 트랜잭션은 현재 블록에 담기게 됩니다. CN은 블록 가스 한도나 블록 생성 제한 시간에 도달할 때까지 트랜잭션을 모읍니다. 그 후, CN은 트랜잭션이 담긴 블록을 생성합니다. 이 단계에서는 블록의 여러 필드를 채워 넣어야합니다. 예를 들어 트랜잭션, 영수증, 상태 등의 해시를 계산해야 합니다. 채워야하는 모든 필드가 채워지면 CN은 블록 해시를 생성합니다.

블록 생성이 끝나면 블록은 다른 모든 CN들로 전파됩니다. 다른 모든 CN들은 전파된 블록을 검증하고 BFT 합의 알고리즘을 이용하여 검증 결과에 대한 합의에 도달합니다. 필요 숫자 이상의 CN이 검증 과정을 성공적으로 마치면 블록이 블록체인에 저장됩니다. BFT합의 알고리즘은 즉각적인 완결성(immediate finality)을 특성으로 가지므로, 블록은 완결되고 절대 삭제되지 않습니다. 블록이 완결되고 나면 블록의 모든 트랜잭션은 되돌릴 수 없고, 트랜잭션 결과는 발신자가 요청시 리턴됩니다.

### 트랜잭션 실행에 관한 제한 사항 <a id="restrictions-on-transaction-execution"></a>

Klaytn의 Baobab 및 Cypress 네트워크에는 현재 트랜잭션 실행에 관해 다음과 같은 제한이 있습니다.

* 트랜잭션은 가스 가격을 Klaytn의 [단위 가격](../klaytn-native-coin-klay.md/#units-of-klay)으로 설정해야 합니다. _즉_, 25 Gpeb입니다.
* 연산 비용 한도보다 실행 비용이 큰 트랜잭션은 버려집니다. [연산 비용](computation-cost/computation-cost.md)을 참고해주세요.

## 데이터 구조(Data Structures)<a id="data-structures"></a>

### 계정 <a id="account"></a>

Klaytn의 계정(account)은 개인의 잔액이나 스마트 컨트랙트에 관한 정보를 포함하는 데이터 구조입니다. Klaytn은 계정 모델을 재설계하여 더 나은 DX 및 UX를 제공하도록 만들었습니다. 계정 모델에 대한 자세한 정보는 [여기](../accounts.md)서 찾을 수 있습니다.

### 트랜잭션(Transaction)<a id="transaction"></a>

블록체인 플랫폼의 트랜잭션은 블록체인의 상태를 변경하는 노드간 전송되는 메시지입니다. Klaytn은 트랜잭션 모델 또한 재설계했습니다. 성능을 최적화하고, 새로 설계된 계정 모델을 지원할 수 있도록 트랜잭션의 목적에 따라 트랜잭션은 여러 종류로 분류되어 있습니다. 계정 모델에 대한 자세한 정보는 [여기](../transactions/)서 찾을 수 있습니다.

### 상태(State)<a id="state"></a>

Klaytn의 **상태**는 계정 상태를 모은 것입니다. Klaytn의 노드들이 같은 블록들을 같은 순서대로 처리했다면 상태는 Klaytn 네트워크의 모든 노드에서 동일해야 합니다. 상태는 Klaytn 노드에서 트랜잭션이 실행될 때 변경됩니다.

아래 표는 상태에 저장된 계정 데이터를 보여줍니다.

| 구성요소        | 설명                                                                                                     |
|:----------- |:------------------------------------------------------------------------------------------------------ |
| Nonce       | 계정에서 실행한 트랜잭션의 수를 나타내는 정숫값입니다. 트랜잭션을 보낼 때 트랜잭션의 논스는 계정의 논스와 같아야합니다.                                    |
| Balance     | 계정이 현재 가지고 있는 KLAY를 나타내는 양의 정숫값입니다.                                                                    |
| StorageRoot | 계정에 저장된 모든 변수들의 값을 포함하는 Merkle Patricia trie 루트의 256비트 해시입니다.                                          |
| CodeHash    | 계정 바이트코드의 해시입니다.  이 값은 변경할 수 없으며, 스마트 컨트랙트가 생성 될 때만 설정됩니다.  계정이 EOA 또는 EA인 경우, 이 값은 null의 해시값으로 설정됩니다. |

### 블록 <a id="block"></a>

블록체인은 문자 그대로 블록을 체인으로 연결한 것이기 때문에 블록은 Klaytn 블록체인의 아주 중요한 요소입니다. 아래 표는 블록의 구성 요소를 보여줍니다.

| 구성요소         | 설명                                               |
|:------------ |:------------------------------------------------ |
| ParentHash   | 부모 블록의 해시                                        |
| Rewardbase   | 블록 보상을 받는 계정 주소                                  |
| Root         | 블록체인 상태의 Merkle Patricia Trie 루트의 해시             |
| TxHash       | 블록에 포함된 트랜잭션들의 해시                                |
| ReceiptHash  | 블록에 포함된 트랜잭션들의 영수증의 해시                           |
| Bloom        | 영수증의 블룸필터 값                                      |
| Number       | 이전 블록 수와 동일한 정숫값                                 |
| GasUsed      | 블록에서 트랜잭션을 처리하는 데 사용된 가스                         |
| Time         | 블록 생성시 Unix 타임스탬프와 동일한 정숫값                       |
| Extra        | 검증자 목록, 제안자 및 참여한 검증자의 seal 등을 포함하는 RLP 인코딩된 문자열 |
| Transactions | 블록에 포함된 트랜잭션들                                    |

## 스마트 컨트랙트 <a id="smart-contract"></a>

_스마트 컨트랙트_는 Klaytn 블록체인의 특정 주소에 있는 코드\(functions\)와 데이터 \(state\)의 모음입니다. 컨트랙트 계정은 실질적으로 튜링 완전한 연산을 수행할 뿐만 아니라 서로 간에 메시지를 전달할 수 있습니다. 스마트 컨트랙트는 블록체인 상에 클레이튼 고유의 바이너리 형식으로 존재합니다. 현재 Klaytn은 한가지 바이너리 형식(Ethereum Virtual Machine \(EVM\) 바이트 코드)을 지원합니다. 하지만 미래에는 다른 형식들도 지원될 예정입니다.

### 스마트 컨트랙트 생성 <a id="creating-smart-contracts"></a>

빈 주소로 바이너리 데이터를 트랜잭션에 담아 보내면 Klaytn 블록체인에 스마트 컨트랙트가 생성됩니다. 바이너리 데이터는 여러 형식으로 존재할 수 있지만, Klaytn에서는 현재 EVM 바이트코드 한 가지만을 지원합니다. 트랜잭션을 실행하기 위해서는 수수료를 지불해야한다는 사실도 기억해주세요. 블록에 트랜잭션이 저장된 후, 발신자의 계정 잔고는 트랜잭션 수수료 모델에 따라서 줄어듭니다. 일정 시간이 지나면 트랙잭션을 블록에서 확인할 수 있으며 이는 트랜잭션 상태가 합의에 도달했음을 알려줍니다. 이 시점부터 스마트 컨트랙트는 Klaytn 블록체인 상에 존재하게 됩니다.

### 스마트 컨트랙트 실행 <a id="executing-smart-contracts"></a>

스마트 컨트랙트의 함수는 스마트 컨트랙트에 트랜잭션을 보내거나 노드에서 로컬로 함수를 호출하여 실행할 수 있습니다. 트랜잭션을 보내 함수가 호출되면, 트랜잭션을 처리하여 함수가 실행됩니다. 트랜잭션을 보내면 Klay가 소모되며, 이 호출은 블록체인 상에 영원히 기록됩니다. 이런 호출의 리턴 값은 트랜잭션의 해시입니다. 로컬에서 함수가 호출되면 Klaytn 가상머신 \(KLVM\)에서 로컬로 실행되며, 함수의 리턴값을 반환합니다. 이런 호출은 블록체인 상에 기록되지 않습니다. 따라서 스마트 컨트랙트의 내부 상태를 바꾸지 않습니다. 이런 종류의 호출은 상수 함수 호출(constant function call)이라고 합니다. 이런 호출은 Klay를 소모하지 않습니다. 상수 함수 호출(constant function call)은 오직 리턴값만 필요할 때 사용하고, 컨트랙트 상태의 부작용(side effect)에 관심이 있으면 트랜잭션을 사용하시면 됩니다.

### 스마트 컨트랙트 비활성화 <a id="disabling-smart-contracts"></a>

스마트 컨트랙트는 Klaytn 블록체인 상에 존재하기 때문에 삭제될 수 없습니다. 오직 비활성화 될 수만 있습니다. 현재 Klaytn 스마트 컨트랙트를 비활성화기 위해서는 이더리움에서 사용된 방식과 같은 방식을 이용할 수 있습니다. 예를 들어, Klaytn 스마트 컨트랙트는 솔리디티의 [`selfdestruct(address recipient)`](https://solidity.readthedocs.io/en/v0.5.6/introduction-to-smart-contracts.html#self-destruct) 호출이나 \(the KLVM opcode `SELFDESTRUCT`\)을 이용하여 비활성화 될 수 있습니다. Klaytn팀은 다른 실행 환경에서 스마트 컨트랙트를 비활성화하는 방법도 제공할 예정입니다.

### 스마트 컨트랙트 업그레이드 <a id="upgrading-smart-contracts"></a>

Klaytn은 현존하는 블록체인의 불편한 사용자 경험 문제를 해결하기 위해 배포된 스마트 컨트랙트를 업그레이드 할 수 있는 방법들을 제공할 것입니다. 예를 들어, 블록체인 상에 배포된 서비스는 업그레이드하기 힘듭니다. Klaytn은 프레임워크와 스마트 컨트랙트 라이브러리를 제공하여 서비스 제공자\(SPs\)가 배포된 서비스를 업그레이드하고, 서비스 정보를 옮길 수 있도록 할 예정입니다. Klatn은 다음 요구사항들을 고려하여 신중히 이 기능을 제공할 것입니다.

* 승인된 계정 또는 스마트 컨트랙트 소유자만 스마트 컨트랙트를 업그레이드 할 수 있어야 합니다.
* 업그레이드된 스마트 컨트랙트는 기존 스마트 컨트랙트가 관리하는 기존 데이터를 조작할 수 있어야 합니다.
* 기존 스마트 컨트랙트를 참고하는 다른 스마트 컨트랙트는 새롭게 업그레이드된 스마트 컨트랙트를 이용할지 결정할 수 있어야 합니다.

