# 7-2. UploadPhoto 컴포넌트

![사진 업로드](../images/klaystagram-uploadphoto.png)

1. `UploadPhoto` 컴포넌트의 역할
2. 컴포넌트 코드
3. 컨트랙트와의 상호작용 
4. 리덕스 스토어의 데이터 업데이트: `updateFeed` 함수

## 1\) `UploadPhoto` 컴포넌트의 역할

`UploadPhoto` 컴포넌트는 Klaytn 블록체인에 사진을 업로드하는 요청을 처리합니다. 다음과 같은 과정을 거쳐 이루어집니다.

1. 트랜잭션을 전송하여 스마트 컨트랙트의 `uploadPhoto` 메서드를 호출합니다. `uploadPhoto` 메서드에서 새로운 ERC-721 토큰이 발행됩니다. 
2. 트랜잭션 전송 후 `Toast` 컴포넌트를 사용하여 트랜잭션 라이프 싸이클로 진행 상황을 나타냅니다. 
3. 트랜잭션이 블록에 담기면 로컬의 리덕스 스토어에서 새로운 `PhotoData`로 업데이트합니다. 

**컨텐츠 크기 제한**  
한 트랜잭션의 최대 크기는 `32KB`입니다. 따라서 안전하게 전송하기 위해 입력되는 데이터\(photo and descriptions\)가 `30KB`를 넘지 않도록 제한합니다.

* 문자열 데이터의 크기는 `2KB`로 제한됩니다.
* 사진은 [`imageCompression()`](https://github.com/underbleu/klaystagram/blob/master/src/utils/imageCompression.js) 함수를 통해 `28KB` 이하로 압축됩니다.

## 2\) 컴포넌트 코드

```javascript
// src/components/UploadPhoto.js

import React, { Component } from 'react'
import { connect } from 'react-redux'
import imageCompression from 'utils/imageCompression';
import ui from 'utils/ui'
import Input from 'components/Input'
import InputFile from 'components/InputFile'
import Textarea from 'components/Textarea'
import Button from 'components/Button'

import * as photoActions from 'redux/actions/photos'

import './UploadPhoto.scss'

// 컨텐츠 크기 제한
const MAX_IMAGE_SIZE = 28000   // 28KB
const MAX_STRING_SIZE = 2000   // 2KB

class UploadPhoto extends Component {
  state = {
    file: '',
    fileName: '',
    location: '',
    caption: '',
    warningMessage: '',
    isCompressing: false,
  }

  handleInputChange = (e) => {
    this.setState({
      [e.target.name]: e.target.value,
    })
  }

  handleFileChange = (e) => {
    const file = e.target.files[0]

    // 이미지의 크기가 MAX_IMAGE_SIZE(28KB)보다 큰 경우
    // 트랜잭션에 올릴 수 있도록 이미지를 압축합니다.
    if (file.size > MAX_IMAGE_SIZE) {
      this.setState({
        isCompressing: true,
      })
      return this.compressImage(file)
    }

    return this.setState({
      file,
      fileName: file.name,
    })
  }

  handleSubmit = (e) => {
    e.preventDefault()
    const { file, fileName, location, caption } = this.state
    this.props.uploadPhoto(file, fileName, location, caption)
    ui.hideModal()
  }

  compressImage = async (imageFile) => {
    const MAX_IMAGE_SIZE_MB = MAX_IMAGE_SIZE / 100000  // 28KB
    try {
      const compressedFile = await imageCompression(imageFile, MAX_IMAGE_SIZE_MB)
      this.setState({
        isCompressing: false,
        file: compressedFile,
        fileName: compressedFile.name,
      })
    } catch (error) {
      this.setState({
        isCompressing: false,
        warningMessage: '* Fail to compress image'
      })
    }
  }

  render() {
    const { fileName, location, caption, isCompressing, warningMessage } = this.state
    return (
      <form className="UploadPhoto" onSubmit={this.handleSubmit}>
        <InputFile
          className="UploadPhoto__file"
          name="file"
          label="Search file"
          fileName={isCompressing ? 'Compressing image...' : fileName}
          onChange={this.handleFileChange}
          err={warningMessage}
          accept=".png, .jpg, .jpeg"
          required
        />
        <Input
          className="UploadPhoto__location"
          name="location"
          label="Location"
          value={location}
          onChange={this.handleInputChange}
          placeholder="Where did you take this photo?"
          required
        />
        <Textarea
          className="UploadPhoto__caption"
          name="caption"
          value={caption}
          label="Caption"
          onChange={this.handleInputChange}
          placeholder="Upload your memories"
          required
        />
        <Button
          className="UploadPhoto__upload"
          type="submit"
          title="Upload"
        />
      </form>
    )
  }
}

const mapDispatchToProps = (dispatch) => ({
  uploadPhoto: (file, fileName, location, caption) =>
    dispatch(photoActions.uploadPhoto(file, fileName, location, caption)),
})

export default connect(null, mapDispatchToProps)(UploadPhoto)
```

## 3\) 컨트랙트와의 상호작용

Klaytn에 사진 데이터를 쓰는 함수를 만들어보겠습니다. **컨트랙트에 트랜잭션 전송: `uploadPhoto`**  
읽기만 가능한 함수를 호출하는 경우와 달리 데이터를 쓰는 것은 트랜잭션 비용이 발생합니다. 트랜잭션 비용은 사용한 `gas`의 양에 따라 결정됩니다. `gas`는 트랜잭션을 처리하는 데에 필요한 계산량을 나타내는 측정 단위입니다.

따라서 트랜잭션을 보내려면 `from`과 `gas` 두 속성이 있어야 합니다.

1. 트랜잭션에 올릴 수 있도록 사진 파일을 바이트 문자열로 변환합니다.
    
    \([Klaystagram contract](../4.-write-klaystagram-smart-contract.md)에서 사진의 형식을 `PhotoData` 구조체의 bytes로 정의했습니다.\)

* `FileReader`를 사용하여 ArrayBuffer로 사진 데이터를 읽어옵니다.
* ArrayBuffer를 16진수 문자열로 변환합니다. 
* bytes 형식으로 맞추기 위해 접두사 `0x`를 추가합니다. 

2. 컨트랙트 메서드를 호출합니다: `uploadPhoto` 
   * `from`: 트랜잭션을 전송하고 트랜잭션 비용을 지불하는 계정입니다. 
   * `gas`: `from`의 계정이 트랜잭션에 지불하고자 하는 최대 가스양입니다.
3. 트랜잭션 전송 후 `Toast` 컴포넌트를 사용하여 트랜잭션 라이프 싸이클로 진행 상황을 나타냅니다.
4. 트랜잭션이 블록에 잘 담기게 되면 `updateFeed` 함수를 호출하여 피드 페이지에 새로운 사진을 추가합니다.

```javascript
// src/redux/actions/photo.js

export const uploadPhoto = (
  file,
  fileName,
  location,
  caption
) => (dispatch) => {
  const reader = new window.FileReader()

  // 1. 트랜잭션에 올릴 수 있도록 사진 파일을 16진수 문자열로 변환합니다.
  reader.readAsArrayBuffer(file)
  reader.onloadend = () => {
    const buffer = Buffer.from(reader.result)
    const bytesString = "0x" + buffer.toString('hex')

    // 2. 컨트랙트 메서드를 호출합니다: uploadPhoto
    // 사진 파일(bytesString)과 설명을 트랜잭션에 담아 전송합니다.
    KlaystagramContract.methods.uploadPhoto(bytesString, fileName, location, caption).send({
      from: getWallet().address,
      gas: '20000000',
    })
      // 3. 트랜잭션 전송 후 
      // 'Toast' 컴포넌트를 사용하여 트랜잭션 라이프 싸이클로 진행 상황을 나타냅니다.
      .once('transactionHash', (txHash) => {
        ui.showToast({
          status: 'pending',
          message: `Sending a transaction... (uploadPhoto)`,
          txHash,
        })
      })
      .once('receipt', (receipt) => {
        ui.showToast({
          status: receipt.status ? 'success' : 'fail',
          message: `Received receipt! It means your transaction is
          in klaytn block (#${receipt.blockNumber}) (uploadPhoto)`,
          link: receipt.transactionHash,
        })

        // 4. 트랜잭션이 블록에 잘 담기게 되면 
        // 'updateFeed' 함수를 호출하여 피드 페이지에 새로운 사진을 추가합니다.
        if(receipt.status) {
          const tokenId = receipt.events.PhotoUploaded.returnValues[0]
          dispatch(updateFeed(tokenId))
        }
      })
      .once('error', (error) => {
        ui.showToast({
          status: 'error',
          message: error.toString(),
        })
      })
  }
}
```

**참고\) 트랜잭션의 라이프 싸이클**

트랜잭션을 전송하면 트랜잭션의 라이프 싸이클\(`transactionHash`, `receipt`, `error`\)을 얻을 수 있습니다.

* `transactionHash` 이벤트는 서명된 트랜잭션 인스턴스가 올바르게 구성되면 발생합니다. 네트워크에 트랜잭션을 전송하기 전에 트랜잭션 해시를 구할 수 있습니다.
* `receipt` 이벤트는 트랜잭션 영수증을 받을 때 발생합니다. 이는 트랜잭션이 블록에 들어갔음을 의미합니다. `receipt.blockNumber`으로 블록 번호를 확인할 수 있습니다. 
* `error` 이벤트는 어떤 문제가 있을 때 발생합니다.

## 4. 피드 페이지의 사진 업데이트: `updateFeed`

컨트랙트에 트랜잭션을 성공적으로 전송하면 FeedPage가 업데이트되어야 합니다.  
사진 피드를 업데이트하려면 업로드한 새 사진의 데이터를 가져와야 합니다. `tokenId`와 함께 `getPhoto()`를 호출합니다. `tokenId`는 트랜잭션 영수증에서 찾을 수 있습니다. 그 다음 새 사진의 데이터를 로컬 리덕스 스토어에 저장하세요.

```javascript
// src/redux/actions/photo.js

/**
 * 1. 컨트랙트 메서드 호출: getPhoto()
 * 업로드한 사진 데이터를 가져오려면 
 * 트랜잭션 영수증에서 tokenId를 가져와 `getPhoto()`를 호출합니다.
*/
const updateFeed = (tokenId) => (dispatch, getState) => {
  KlaystagramContract.methods.getPhoto(tokenId).call()
    .then((newPhoto) => {
      const { photos: { feed } } = getState()
      const newFeed = [newPhoto, ...feed]

      // 2. 리덕스 스토어에 새로운 피드를 업데이트합니다.
      dispatch(setFeed(newFeed))
    })
}
```